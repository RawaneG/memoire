{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nconst API_BASE_URL = 'http://localhost:5000';\n\n// Fallback data when backend is not available\nconst FALLBACK_DATA = {\n  countries: {\n    total_countries: 6,\n    featured_countries: [{\n      name: 'Senegal',\n      has_special_config: true\n    }, {\n      name: 'France',\n      has_special_config: true\n    }, {\n      name: 'Germany',\n      has_special_config: true\n    }],\n    other_countries: [{\n      name: 'United States',\n      has_special_config: false\n    }, {\n      name: 'Brazil',\n      has_special_config: false\n    }, {\n      name: 'India',\n      has_special_config: false\n    }]\n  },\n  models: {\n    available_models: {\n      linear: {\n        name: 'Linear Regression',\n        description: 'Simple, fast and interpretable',\n        best_for: ['limited data', 'linear trends']\n      },\n      random_forest: {\n        name: 'Random Forest',\n        description: 'Robust ensemble model',\n        best_for: ['complex data', 'non-linear relationships']\n      },\n      gradient_boost: {\n        name: 'Gradient Boosting',\n        description: 'Advanced high-precision model',\n        best_for: ['precise predictions', 'large datasets']\n      }\n    },\n    recommended_by_country: {\n      Senegal: 'random_forest',\n      France: 'gradient_boost',\n      Germany: 'gradient_boost'\n    }\n  }\n};\nexport const useApi = () => {\n  _s();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const request = useCallback(async (endpoint, options = {}) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const url = `${API_BASE_URL}${endpoint}`;\n      const response = await fetch(url, {\n        headers: {\n          'Content-Type': 'application/json',\n          ...options.headers\n        },\n        ...options\n      });\n      if (!response.ok) {\n        throw new Error(`API Error: ${response.status} ${response.statusText}`);\n      }\n      const data = await response.json();\n      return data;\n    } catch (err) {\n      console.warn(`API request failed: ${err.message}. Using fallback data.`);\n\n      // Return fallback data based on endpoint\n      if (endpoint === '/countries') {\n        return FALLBACK_DATA.countries;\n      } else if (endpoint === '/models') {\n        return FALLBACK_DATA.models;\n      }\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n  const predict = useCallback(async (country, model, horizon) => {\n    const params = new URLSearchParams({\n      country,\n      model,\n      horizon: horizon.toString()\n    });\n    return request(`/predict?${params}`);\n  }, [request]);\n  const getCountries = useCallback(async () => {\n    return request('/countries');\n  }, [request]);\n  const getModels = useCallback(async () => {\n    return request('/models');\n  }, [request]);\n  const getHealth = useCallback(async () => {\n    return request('/health');\n  }, [request]);\n  return {\n    loading,\n    error,\n    predict,\n    getCountries,\n    getModels,\n    getHealth,\n    clearError: () => setError(null)\n  };\n};\n_s(useApi, \"VYpUo+V5+w9rPovuAyW8oNpy+u0=\");","map":{"version":3,"names":["useState","useCallback","API_BASE_URL","FALLBACK_DATA","countries","total_countries","featured_countries","name","has_special_config","other_countries","models","available_models","linear","description","best_for","random_forest","gradient_boost","recommended_by_country","Senegal","France","Germany","useApi","_s","loading","setLoading","error","setError","request","endpoint","options","url","response","fetch","headers","ok","Error","status","statusText","data","json","err","console","warn","message","predict","country","model","horizon","params","URLSearchParams","toString","getCountries","getModels","getHealth","clearError"],"sources":["C:/Users/snsowr/Desktop/Code/OWID/frontend/src/hooks/useApi.js"],"sourcesContent":["import { useState, useCallback } from 'react';\n\nconst API_BASE_URL = 'http://localhost:5000';\n\n// Fallback data when backend is not available\nconst FALLBACK_DATA = {\n  countries: {\n    total_countries: 6,\n    featured_countries: [\n      { name: 'Senegal', has_special_config: true },\n      { name: 'France', has_special_config: true },\n      { name: 'Germany', has_special_config: true }\n    ],\n    other_countries: [\n      { name: 'United States', has_special_config: false },\n      { name: 'Brazil', has_special_config: false },\n      { name: 'India', has_special_config: false }\n    ]\n  },\n  models: {\n    available_models: {\n      linear: {\n        name: 'Linear Regression',\n        description: 'Simple, fast and interpretable',\n        best_for: ['limited data', 'linear trends']\n      },\n      random_forest: {\n        name: 'Random Forest',\n        description: 'Robust ensemble model',\n        best_for: ['complex data', 'non-linear relationships']\n      },\n      gradient_boost: {\n        name: 'Gradient Boosting',\n        description: 'Advanced high-precision model',\n        best_for: ['precise predictions', 'large datasets']\n      }\n    },\n    recommended_by_country: {\n      Senegal: 'random_forest',\n      France: 'gradient_boost',\n      Germany: 'gradient_boost'\n    }\n  }\n};\n\nexport const useApi = () => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const request = useCallback(async (endpoint, options = {}) => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const url = `${API_BASE_URL}${endpoint}`;\n      const response = await fetch(url, {\n        headers: {\n          'Content-Type': 'application/json',\n          ...options.headers,\n        },\n        ...options,\n      });\n\n      if (!response.ok) {\n        throw new Error(`API Error: ${response.status} ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      return data;\n    } catch (err) {\n      console.warn(`API request failed: ${err.message}. Using fallback data.`);\n      \n      // Return fallback data based on endpoint\n      if (endpoint === '/countries') {\n        return FALLBACK_DATA.countries;\n      } else if (endpoint === '/models') {\n        return FALLBACK_DATA.models;\n      }\n      \n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  const predict = useCallback(async (country, model, horizon) => {\n    const params = new URLSearchParams({\n      country,\n      model,\n      horizon: horizon.toString(),\n    });\n    \n    return request(`/predict?${params}`);\n  }, [request]);\n\n  const getCountries = useCallback(async () => {\n    return request('/countries');\n  }, [request]);\n\n  const getModels = useCallback(async () => {\n    return request('/models');\n  }, [request]);\n\n  const getHealth = useCallback(async () => {\n    return request('/health');\n  }, [request]);\n\n  return {\n    loading,\n    error,\n    predict,\n    getCountries,\n    getModels,\n    getHealth,\n    clearError: () => setError(null),\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}